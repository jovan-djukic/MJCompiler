program TypeChecksWithErrors

const int const1 = 5;

class class1 {
	int a, b, c;
	
	{
		int method1(int a, char b, int c)
			int d;
		{

		}
		
		static void staticMethod1(int a, int b, int c) {
		
		}
	}
}

class class2 extends class1 {
	int d, e, f, g, h;
	
	{
		void method2() {
		
		}
	}
}

{
	int globalFunction1(int parameter1, int parameter2, char parameter3)
		int local1, local2[];
		char local3[], local4;
	{
			
	}
	
	void globalFunction2(class2 instance) {
	
	}
	
	void main()
		class1 instance1, instance2;
		class2 instance3;
		int a;
		char c[], d[];
	{
		//new operator
		instance1 = new int;
		
		//Expression types
		a = 5 + 5 * 'c' + 5  += true;
		c = new char['c'];
		d = new char[instance1];
		
		//expression types
		instance1.a +=  const1 *= 5;
		a += const1 += 5;
		b[0] += a;
		a = - c[0];
		
		if ( a == d[5]) {
			if (instance1 > instance2) {
			
				//parameter count and type for global function
				globalFunction1();
				globalFunction1('a', 1, 2);
				globalFunction1(1, 2, globalFunction1(1, 2, 'a'));
			}
		}
		
		//parameter count and types for method
		instance1.method1(1, 'a');
		instance1.method1(1, 'a', 2, 3);
		
		//parameter count and types for method when using factor production instead of designator statement production
		a += instance1.method1(1, 'a', 2, 3) + instance1.method1(1, 'a', 'b');
		
		//parameter count and type, super class - sub class irregular situation
		globalFunction2(instance1);
		
		//increment and decrement type checks
		const1++;
		c[2] ++;
		
		a = a + a += instance1;
		
		//Assign operator type checks
		const1 = 2;
		a = '5';
		instance3 = instance1;
		instance3 += instance1;
	}
}	